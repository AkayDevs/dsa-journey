{
  "GeeksforGeeks Solution Template": {
    "prefix": "gfg",
    "description": "Template for GeeksforGeeks problems with helper functions",
    "body": [
      "#!/usr/bin/env python3",
      "from typing import List, Optional, Dict, Any, Tuple",
      "import sys",
      "import os",
      "from collections import deque",
      "from pathlib import Path",
      "",
      "# ----- Input/Output Setup -----",
      "",
      "input_file = None",
      "output_file = None",
      "input_lines = []",
      "line_index = 0",
      "",
      "# Project root directory - modify this if needed",
      "# This can also be determined using environment variables or by searching for common project files",
      "PROJECT_ROOT = Path(os.path.dirname(os.path.abspath(__file__))).parent",
      "",
      "def setup_io():",
      "    \"\"\"Setup input and output sources, checking both local and project root directories\"\"\"",
      "    global input_file, output_file, input_lines, line_index",
      "    ",
      "    # Try to open input file (first in current directory, then in project root)",
      "    current_dir_input = Path('input.txt')",
      "    root_dir_input = PROJECT_ROOT / 'input.txt'",
      "    ",
      "    try:",
      "        # Try current directory first",
      "        if current_dir_input.exists():",
      "            input_file = open(current_dir_input, 'r')",
      "            print(f\"Reading input from {current_dir_input}\")",
      "        # Then try project root",
      "        elif root_dir_input.exists():",
      "            input_file = open(root_dir_input, 'r')",
      "            print(f\"Reading input from {root_dir_input}\")",
      "        else:",
      "            print(\"No input.txt found in current directory or project root, reading from console\")",
      "        ",
      "        # If we opened a file, read all lines",
      "        if input_file:",
      "            input_lines = input_file.readlines()",
      "            print(f\"Read {len(input_lines)} lines from input file\")",
      "    except Exception as e:",
      "        print(f\"Error opening input file: {e}\")",
      "        print(\"Reading from console\")",
      "    ",
      "    # Try to open output file (first in current directory, then in project root)",
      "    current_dir_output = Path('output.txt')",
      "    root_dir_output = PROJECT_ROOT / 'output.txt'",
      "    ",
      "    try:",
      "        # Try current directory first",
      "        if os.access(os.path.dirname(current_dir_output.absolute()), os.W_OK):",
      "            output_file = open(current_dir_output, 'w')",
      "            print(f\"Writing output to {current_dir_output}\")",
      "        # Then try project root",
      "        elif os.access(os.path.dirname(root_dir_output.absolute()), os.W_OK):",
      "            output_file = open(root_dir_output, 'w')",
      "            print(f\"Writing output to {root_dir_output}\")",
      "        else:",
      "            print(\"Could not open output.txt in current directory or project root, writing to console only\")",
      "    except Exception as e:",
      "        print(f\"Error opening output file: {e}\")",
      "        print(\"Writing to console only\")",
      "",
      "def cleanup_io():",
      "    \"\"\"Close open files\"\"\"",
      "    if input_file:",
      "        input_file.close()",
      "    if output_file:",
      "        output_file.close()",
      "",
      "def read_line() -> str:",
      "    \"\"\"Read a line from input file or console\"\"\"",
      "    global line_index",
      "    if input_lines:",
      "        if line_index < len(input_lines):",
      "            line = input_lines[line_index].strip()",
      "            line_index += 1",
      "            return line",
      "        else:",
      "            raise EOFError(\"Reached end of input file\")",
      "    else:",
      "        return input().strip()",
      "",
      "def write_output(result):",
      "    \"\"\"Write result to output file or console\"\"\"",
      "    output_str = str(result)",
      "    if output_file:",
      "        output_file.write(output_str + '\\n')",
      "    print(output_str)",
      "",
      "# ----- Helper Functions for Parsing Input -----",
      "",
      "def read_int() -> int:",
      "    \"\"\"Read a single integer from input\"\"\"",
      "    return int(read_line())",
      "",
      "def read_float() -> float:",
      "    \"\"\"Read a single float from input\"\"\"",
      "    return float(read_line())",
      "",
      "def read_str() -> str:",
      "    \"\"\"Read a single string from input\"\"\"",
      "    return read_line()",
      "",
      "def read_list_int() -> List[int]:",
      "    \"\"\"Read a list of integers from input\"\"\"",
      "    return list(map(int, read_line().split()))",
      "",
      "def read_list_float() -> List[float]:",
      "    \"\"\"Read a list of floats from input\"\"\"",
      "    return list(map(float, read_line().split()))",
      "",
      "def read_list_str() -> List[str]:",
      "    \"\"\"Read a list of strings from input\"\"\"",
      "    return read_line().split()",
      "",
      "def read_grid(rows: int) -> List[List[int]]:",
      "    \"\"\"Read a grid of integers with the specified number of rows\"\"\"",
      "    return [read_list_int() for _ in range(rows)]",
      "",
      "def read_grid_char(rows: int) -> List[List[str]]:",
      "    \"\"\"Read a grid of characters with the specified number of rows\"\"\"",
      "    return [list(read_line()) for _ in range(rows)]",
      "",
      "# ----- Data Structure Definitions -----",
      "",
      "# Linked List Node",
      "class Node:",
      "    def __init__(self, data):",
      "        self.data = data",
      "        self.next = None",
      "",
      "# Binary Tree Node",
      "class TreeNode:",
      "    def __init__(self, val):",
      "        self.val = val",
      "        self.left = None",
      "        self.right = None",
      "",
      "# ----- Solution Class -----",
      "",
      "class Solution:",
      "    \"\"\"",
      "    Your solution implementation goes here.",
      "    For GeeksforGeeks, implement the function with the exact signature they require.",
      "    \"\"\"",
      "    def ${1:function_name}(self, ${2:parameters}) -> ${3:return_type}:",
      "        \"\"\"${4:Function description}\"\"\"",
      "        ${5:# TODO: Implement your solution}",
      "        ${6:pass}",
      "",
      "def main():",
      "    setup_io()",
      "    ",
      "    try:",
      "        # GFG typically has multiple test cases",
      "        t = read_int()  # Number of test cases",
      "        ",
      "        for _ in range(t):",
      "            # Parse input for each test case",
      "            ${7:# TODO: Parse input for this test case}",
      "            ${8:# Example: n = read_int()}",
      "            ${9:# Example: arr = read_list_int()}",
      "            ",
      "            # Create solution object and call the function",
      "            solution = Solution()",
      "            result = solution.${1:function_name}(${10:arguments})",
      "            ",
      "            # Output result for this test case",
      "            write_output(result)",
      "    ",
      "    finally:",
      "        cleanup_io()",
      "",
      "if __name__ == \"__main__\":",
      "    main()"
    ]
  }
} 